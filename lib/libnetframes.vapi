/* libnetframes.vapi generated by valac.exe 0.20.1, do not modify. */

namespace NetFrames {
	[CCode (cheader_filename = "libnetframes.h")]
	public class Capture : GLib.Object {
		public GLib.InetAddress capture_from;
		public bool compatibility_mode;
		public NetFrames.PCapHeader pcap_header;
		public Capture (string filename, GLib.InetAddress? capture_from = null, bool shark_decode = true);
		public Capture.Null ();
		public void build_structures ();
		public void delete_connection (NetFrames.Connection c);
		public void delete_host (GLib.InetAddress host);
		public void delete_session (NetFrames.Session s);
		public void display ();
		public void display_connection_frames (GLib.InetAddress host);
		public void display_host_frames (GLib.InetAddress host);
		public NetFrames.Frame get_first_frame_captured ();
		public void save_pcap (string uri);
		public void set_captured_host (GLib.InetAddress host);
		public NetFrames.Connections connections { get; }
		public string filename { get; }
		public NetFrames.Frames frames { get; }
		public NetFrames.Hosts hosts { get; }
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class Connection : GLib.Object {
		public GLib.InetAddress host_a;
		public GLib.InetAddress host_b;
		public int32 latency;
		public NetFrames.Sessions sessions;
		public int32 suggested_latency;
		public Connection (GLib.InetAddress a, GLib.InetAddress b);
		public int64 calcul_suggested_latency (GLib.InetAddress capture_from);
		public void delete_session (NetFrames.Session s);
		public void display ();
		public bool has_host (GLib.InetAddress host);
		public bool is_equal (NetFrames.Connection c);
		public string to_string ();
		public int total_frames ();
		public uint32 size_from_host_a { get; }
		public uint32 size_from_host_b { get; }
		public uint32 total_size { get; }
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class Connections : Gee.ArrayList<NetFrames.Connection> {
		public int size_from_host_a;
		public int size_from_host_b;
		public int total_size;
		public Connections ();
		public void display ();
		public GLib.InetAddress get_host_by_max_peers (NetFrames.Hosts hosts);
		public NetFrames.Connection search_connection (NetFrames.Connection to_search);
		public NetFrames.Connection? search_connection_by_host (GLib.InetAddress host);
		public NetFrames.Session search_session_by_host (NetFrames.Connections connections, NetFrames.SocketInfos host);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class EtherHeader : GLib.Object {
		public uint8 ether_dhost[6];
		public uint8 ether_shost[6];
		public uint16 ether_type;
		public EtherHeader ();
		public void display ();
		public EtherHeader.from_buffer (uint8[] pkt, ref int cursor);
		public EtherHeader.from_inputstream (GLib.DataInputStream dis, bool compat_mode = false);
		public static ulong size ();
		public void write_stream (GLib.DataOutputStream dos);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class FlowInformations : GLib.Object {
		public Gee.HashMap<uint32,uint32> assoc_grouped_frames;
		public Gee.TreeMap<uint32,uint32> assoc_seq_acknowledged;
		public Gee.ArrayList<NetFrames.seq_ack_frame> seq_ack_done;
		public FlowInformations (NetFrames.Session s);
		public void display_groups ();
		public void display_seq_ack ();
		public bool has_reference_frame (NetFrames.Frame f, out NetFrames.Frame reference);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class FlowTCPSession {
		public enum STATUS {
			NIHL,
			SYN_SENT,
			SYN_RECEIVED,
			ESTABLISHED,
			FIN_WAIT_1,
			FIN_WAIT_2__CLOSE_WAIT,
			TIME_WAIT__LAST_ACK,
			LAST_ACK,
			CLOSED,
			RESET,
			EXPIRED
		}
		public NetFrames.FlowTCPSession.STATUS status;
		public FlowTCPSession (NetFrames.Session s);
		public void determine_status ();
		public bool eos ();
		public bool first (out NetFrames.Frame f);
		public new NetFrames.Frame @get (int p_index = -1);
		public bool get_previous (out NetFrames.Frame f);
		public bool go_after_handshake ();
		public bool has_next ();
		public bool has_previous ();
		public int index ();
		public bool last ();
		public bool next (out NetFrames.Frame f);
		public bool previous ();
		public int size { get; }
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class Frame : GLib.Object {
		public string dissect;
		public uint32 num;
		public NetFrames.PCapFrame pcap_frame;
		public string proto;
		public NetFrames.seq_ack_frame seq_ack;
		public Frame ();
		public Frame.PCap (NetFrames.PCapFrame f);
		public Frame.Shark_Array (string[] ar_datas);
		public Frame.Shark_String (string s);
		public NetFrames.Connection create_connection ();
		public NetFrames.Session create_session ();
		public void display ();
		public void display_flags ();
		public bool equal (NetFrames.Frame f);
		public bool has_host (GLib.InetAddress host);
		public bool has_port (uint16 port);
		public NetFrames.Connection connection { get; }
		public GLib.InetAddress dst { get; set; }
		public uint16 dst_port { get; }
		public uint16 ip_checksum { get; }
		public uint32 len { get; }
		public uint32 rel_ack { get; }
		public uint32 rel_seq { get; }
		public NetFrames.Session session { get; }
		public GLib.InetAddress src { get; set; }
		public uint16 src_port { get; }
		public NetFrames.TCPFlags tcp_flags { get; }
		public GLib.TimeVal time { get; set; }
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class Frames : NetFrames.SortedList<NetFrames.Frame> {
		public Frames ();
		public void display ();
		public NetFrames.Frame get_frame_by_num (uint32 num);
		public void load_pcap_file (string filename, NetFrames.Capture capture, bool compatibility_mode = false);
		public void save_pcap (string output_filename);
		public NetFrames.Frame search_frame (NetFrames.Frame to_search);
		public void tshark_decode (string filename, NetFrames.Capture capture);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class GroupedFrames {
		public NetFrames.Frame from_frame;
		public NetFrames.Frames to_frames;
		public GroupedFrames ();
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class Hosts : Gee.ArrayList<GLib.InetAddress> {
		public Hosts ();
		public new bool contains (GLib.InetAddress addr);
		public void display ();
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class IPHeader : GLib.Object {
		public GLib.InetAddress dst;
		public uint32 ip_dst;
		public uint16 ip_id;
		public uint16 ip_len;
		public uint16 ip_off;
		public uint8 ip_proto;
		public uint32 ip_src;
		public uint16 ip_sum;
		public uint8 ip_tos;
		public uint8 ip_ttl;
		public uint8 ip_vhl;
		public GLib.InetAddress src;
		public IPHeader ();
		public void display ();
		public IPHeader.from_buffer (uint8[] pkt, ref int cursor);
		public IPHeader.from_inputstream (GLib.DataInputStream dis, bool compat_mode = false);
		public static ulong size ();
		public void write_stream (GLib.DataOutputStream dos);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class PCapFrame : GLib.Object {
		public uint8[] datas;
		public NetFrames.EtherHeader ether_hdr;
		public NetFrames.IPHeader ip_hdr;
		public NetFrames.PCapRecordHeader rec;
		public NetFrames.TCPHeader tcp_hdr;
		public NetFrames.UDPHeader udp_hdr;
		public PCapFrame (uint8[] buffer);
		public void display ();
		public PCapFrame.from_buffer (NetFrames.PCapRecordHeader p_rec, uint8[] pkt_data);
		public PCapFrame.from_datainputstream (NetFrames.PCapRecordHeader p_rec, GLib.DataInputStream dis, bool compat_mode);
		public void write_stream (GLib.DataOutputStream dos);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class PCapHeader : GLib.Object {
		public uint32 magic_number;
		public uint32 network;
		public uint32 sigfigs;
		public uint32 snaplen;
		public int32 thiszone;
		public uint16 version_major;
		public uint16 version_minor;
		public PCapHeader ();
		public void display ();
		public PCapHeader.from_datainputstream (GLib.DataInputStream dis, bool compat_mode = false);
		public void write_stream (GLib.DataOutputStream dos);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class PCapRecordHeader : GLib.Object {
		public uint32 incl_len;
		public uint32 orig_len;
		public GLib.TimeVal ts;
		public PCapRecordHeader ();
		public PCapRecordHeader.from_PCap_header (PCap.packet_header header);
		public PCapRecordHeader.from_datainputstream (GLib.DataInputStream dis, bool compat_mode = false);
		public void write_stream (GLib.DataOutputStream dos);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class Session : GLib.Object {
		public enum SESSION_TYPE {
			UNKNOWN,
			TCP,
			UDP
		}
		public NetFrames.SocketInfos first_frame_host;
		public NetFrames.FlowInformations flow_informations;
		public Gee.ArrayList<NetFrames.Frame> frames;
		public NetFrames.SocketInfos host_a;
		public NetFrames.SocketInfos host_b;
		public NetFrames.SocketInfos second_frame_host;
		public uint32 seq_syn;
		public uint32 seq_syn_ack;
		public NetFrames.Session.SESSION_TYPE session_type;
		public uint32 size_from_host_a;
		public uint32 size_from_host_b;
		public uint32 total_size;
		public Session (NetFrames.SocketInfos a, NetFrames.SocketInfos b);
		public bool detect_client_server ();
		public void display ();
		public Session.from_addr (GLib.InetAddress a, uint16 port_a, GLib.InetAddress b, uint16 port_b);
		public NetFrames.Frame get_frame_by_num (uint32 n);
		public NetFrames.Frame get_from_flags (uint8 flags);
		public bool get_next_from_frame (NetFrames.Frame f, out NetFrames.Frame next);
		public bool has_host (GLib.InetAddress host);
		public bool in_session (NetFrames.Session s);
		public bool is_equals (NetFrames.Session s);
		public string to_string ();
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class Sessions : Gee.ArrayList<NetFrames.Session> {
		public uint32 size_from_host_a;
		public uint32 size_from_host_b;
		public uint32 total_size;
		public Sessions ();
		public void display ();
		public NetFrames.Session search_session (NetFrames.Session to_search);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class SocketInfos : GLib.Object {
		public GLib.InetAddress addr;
		public uint16 port;
		public SocketInfos (GLib.InetAddress a, uint16 p);
		public bool is_equals (NetFrames.SocketInfos s);
		public string to_string ();
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class SortedList<G> : GLib.Object, Gee.Traversable<G>, Gee.Iterable<G>, Gee.Collection<G> {
		protected Gee.ArrayList<G> list;
		public SortedList (NetFrames.Comparator? cmp = null);
		public bool add_list (Gee.List<G> items);
		public virtual void clear ();
		public NetFrames.SortedList<G> copy ();
		public G get_at (int index);
		public int get_count ();
		public int index_of (G search);
		public int locate (G search, bool altered, GLib.EqualFunc equal_func = GLib.direct_equal);
		public G remove_at (int index);
		public void resort (NetFrames.Comparator new_cmp);
		public bool resort_item (G item);
		public Gee.List<G> read_only_view_as_list { owned get; }
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class TCPFlags {
		public uint8 flags;
		public TCPFlags (uint8 value);
		public bool equal (NetFrames.TCPFlags f);
		public string to_string ();
		public bool ACK { get; }
		public bool FIN { get; }
		public bool PSH { get; }
		public bool RST { get; }
		public bool SYN { get; }
		public bool URG { get; }
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class TCPHeader : GLib.Object {
		public uint8[] options;
		public NetFrames.TCPFlags tcp_flags;
		public uint32 th_ack;
		public uint16 th_dport;
		public uint8 th_flags;
		public uint8 th_offset;
		public uint32 th_seq;
		public uint16 th_sport;
		public uint16 th_sum;
		public uint16 th_urg;
		public uint16 th_win;
		public TCPHeader ();
		public void display ();
		public TCPHeader.from_buffer (uint8[] pkt, ref int cursor);
		public TCPHeader.from_inputstream (GLib.DataInputStream dis, bool compat_mode = false);
		public static ulong size ();
		public void write_stream (GLib.DataOutputStream dos);
		public int length { get; }
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class UDPHeader : GLib.Object {
		public uint16 uh_dport;
		public uint16 uh_len;
		public uint16 uh_sport;
		public uint16 uh_sum;
		public UDPHeader ();
		public UDPHeader.from_buffer (uint8[] pkt, ref int cursor);
		public UDPHeader.from_inputstream (GLib.DataInputStream dis, bool compat_mode = false);
		public static ulong size ();
		public void write_stream (GLib.DataOutputStream dos);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public class seq_ack_frame {
		public uint32 ack;
		public uint32 seq;
		public seq_ack_frame (NetFrames.Frame f);
		public seq_ack_frame.from_uint32 (uint32 s, uint32 a);
	}
	[CCode (cheader_filename = "libnetframes.h")]
	public delegate int64 Comparator (void* a, void* b);
	[CCode (cheader_filename = "libnetframes.h")]
	public static int latency;
	[CCode (cheader_filename = "libnetframes.h")]
	public const uint8 ACK;
	[CCode (cheader_filename = "libnetframes.h")]
	public const uint8 CWR;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int DEFAULT_LAN_LATENCY;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int DEFAULT_WAN_LATENCY;
	[CCode (cheader_filename = "libnetframes.h")]
	public const uint8 ECN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int ETHER_ADDR_LEN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int ETHER_CRC_LEN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int ETHER_HDR_LEN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int ETHER_MAX_LEN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int ETHER_MIN_LEN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int ETHER_TYPE_LEN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const uint8 FIN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int PROTO_TCP;
	[CCode (cheader_filename = "libnetframes.h")]
	public const int PROTO_UDP;
	[CCode (cheader_filename = "libnetframes.h")]
	public const uint8 PSH;
	[CCode (cheader_filename = "libnetframes.h")]
	public const uint8 RST;
	[CCode (cheader_filename = "libnetframes.h")]
	public const uint8 SYN;
	[CCode (cheader_filename = "libnetframes.h")]
	public const uint8 URG;
	[CCode (cheader_filename = "libnetframes.h")]
	public static int64 comparator (void* a, void* b);
	[CCode (cheader_filename = "libnetframes.h")]
	public static string frame_to_string (NetFrames.Session s, NetFrames.Frame f);
	[CCode (cheader_filename = "libnetframes.h")]
	public static void hexdump (uint8[] buffer, uint32 len, int largeur = 16);
	[CCode (cheader_filename = "libnetframes.h")]
	public static string latency_to_string (int32 latency);
}
